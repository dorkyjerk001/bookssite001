<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ex-Girlfriend Wedding</title>
<style>
  /* Reset & base */
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; background: #111;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #eee;
    overflow-x: hidden;
    user-select: none;
  }
  h1 {
    text-align: center;
    margin: 20px 0 40px;
    font-size: 3.2rem;
    font-weight: 900;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: #f48fb1;
    text-shadow: 0 0 10px #f48fb1aa;
    animation: titlePulse 3s ease-in-out infinite;
  }
  @keyframes titlePulse {
    0%, 100% { text-shadow: 0 0 10px #f48fb1aa; }
    50% { text-shadow: 0 0 25px #f48fb1ff; }
  }

  /* Gallery grid container */
  .gallery-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill,minmax(180px,1fr));
    gap: 16px;
    max-width: 1200px;
    margin: 0 auto 60px;
    padding: 0 12px;
  }

  /* Thumbnail images */
  .gallery-grid img {
    width: 100%;
    height: 140px;
    object-fit: cover;
    border-radius: 12px;
    box-shadow: 0 4px 12px #f48fb140;
    cursor: pointer;
    transform-origin: center center;
    animation: floatPulse 4s ease-in-out infinite;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }
  .gallery-grid img:hover {
    transform: scale(1.1);
    box-shadow: 0 8px 24px #f48fb1cc;
  }
  @keyframes floatPulse {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-8px); }
  }

  /* Gallery fullscreen overlay */
  .gallery-overlay {
    position: fixed;
    inset: 0;
    background: rgba(17,17,17,0.95);
    backdrop-filter: blur(8px);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    overflow: hidden;
    user-select: none;
  }
  .gallery-overlay.visible {
    display: flex;
    animation: fadeIn 0.4s ease forwards;
  }
  @keyframes fadeIn {
    from {opacity: 0;}
    to {opacity: 1;}
  }

  /* Gallery content wrapper */
  .gallery-content {
    position: relative;
    max-width: 90vw;
    max-height: 90vh;
    overflow: hidden;
    border-radius: 18px;
    box-shadow: 0 0 40px #f48fb1cc;
    background: #222;
  }

  /* Controls container */
  .controls {
    position: absolute;
    top: 50%;
    width: 100%;
    height: 0;
    display: flex;
    justify-content: space-between;
    pointer-events: none;
    user-select: none;
  }

  /* Buttons */
  button.control-btn {
    pointer-events: all;
    background: #f48fb1cc;
    border: none;
    border-radius: 50%;
    color: #222;
    font-size: 2.5rem;
    width: 56px;
    height: 56px;
    margin: 0 12px;
    cursor: pointer;
    transition: background-color 0.2s ease;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 0 8px #f48fb1a0;
  }
  button.control-btn:hover {
    background: #f48fb1ff;
  }

  /* Close button top right */
  button.close-btn {
    position: absolute;
    top: 18px;
    right: 18px;
    width: 48px;
    height: 48px;
    font-size: 2rem;
    background: #f48fb1cc;
    box-shadow: 0 0 10px #f48fb1a0;
  }
  button.close-btn:hover {
    background: #f48fb1ff;
  }

  /* Image container for pan & zoom */
  .image-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    cursor: grab;
    touch-action: none;
    background: #111;
  }

  .image-wrapper:active {
    cursor: grabbing;
  }

  /* Fullscreen image */
  .gallery-img {
    max-width: 100%;
    max-height: 100%;
    user-select: none;
    pointer-events: none; /* to allow drag on wrapper */
    will-change: transform;
    border-radius: 12px;
    transition: transform 0.3s ease;
  }

  @media (max-width: 600px) {
    .gallery-grid {
      grid-template-columns: repeat(auto-fill,minmax(120px,1fr));
      gap: 12px;
      max-width: 100vw;
      margin-bottom: 40px;
    }
    .gallery-grid img {
      height: 90px;
      border-radius: 10px;
    }
    h1 {
      font-size: 2.4rem;
      margin-bottom: 30px;
    }
    button.control-btn {
      width: 44px;
      height: 44px;
      font-size: 1.8rem;
      margin: 0 8px;
    }
  }
</style>
</head>
<body>
  <h1>Ex-Girlfriend Wedding</h1>

  <div class="gallery-grid" aria-label="Wedding image gallery">
    <!-- Images inserted via JS -->
  </div>

  <!-- Fullscreen Gallery Overlay -->
  <div class="gallery-overlay" role="dialog" aria-modal="true" aria-label="Image viewer">
    <button class="close-btn" aria-label="Close gallery">&times;</button>
    <div class="gallery-content" tabindex="0">
      <div class="image-wrapper">
        <img src="" alt="Wedding image" class="gallery-img" draggable="false" />
      </div>
      <div class="controls">
        <button class="control-btn prev-btn" aria-label="Previous image">&#10094;</button>
        <button class="control-btn next-btn" aria-label="Next image">&#10095;</button>
      </div>
    </div>
  </div>

<script>
  // Image filenames array as given
  const imageFiles = [
    "wdng001.jpg", "wdng009.jpg", "wdng017.jpg", "wdng025.jpg", "wdng033.jpg", "wdng041.jpg",
    "wdng002.jpg", "wdng010.jpg", "wdng018.jpg", "wdng026.jpg", "wdng034.jpg", "wdng042.jpg",
    "wdng003.jpg", "wdng011.jpg", "wdng019.jpg", "wdng027.jpg", "wdng035.jpg", "wdng043.jpg",
    "wdng004.jpg", "wdng012.jpg", "wdng020.jpg", "wdng028.jpg", "wdng036.jpg", "wdng044.jpg",
    "wdng005.jpg", "wdng013.jpg", "wdng021.jpg", "wdng029.jpg", "wdng037.jpg",
    "wdng006.jpg", "wdng014.jpg", "wdng022.jpg", "wdng030.jpg", "wdng038.jpg",
    "wdng007.jpg", "wdng015.jpg", "wdng023.jpg", "wdng031.jpg", "wdng039.jpg",
    "wdng008.jpg", "wdng016.jpg", "wdng024.jpg", "wdng032.jpg", "wdng040.jpg"
  ];

  const galleryGrid = document.querySelector('.gallery-grid');
  const galleryOverlay = document.querySelector('.gallery-overlay');
  const galleryImg = document.querySelector('.gallery-img');
  const closeBtn = document.querySelector('.close-btn');
  const prevBtn = document.querySelector('.prev-btn');
  const nextBtn = document.querySelector('.next-btn');
  const galleryContent = document.querySelector('.gallery-content');
  const imageWrapper = document.querySelector('.image-wrapper');

  let currentIndex = 0;

  // Populate the grid with thumbnails
  imageFiles.forEach((filename, i) => {
    const img = document.createElement('img');
    img.src = filename;
    img.alt = `Wedding image ${i + 1}`;
    img.loading = "lazy";
    img.tabIndex = 0;
    img.addEventListener('click', () => openGallery(i));
    img.addEventListener('keydown', e => {
      if(e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        openGallery(i);
      }
    });
    galleryGrid.appendChild(img);
  });

  // Open gallery overlay and show image at index
  function openGallery(index) {
    currentIndex = index;
    resetTransform();
    setImageSrc(currentIndex);
    galleryOverlay.classList.add('visible');
    // Focus gallery for keyboard controls
    galleryContent.focus();
    // Prevent body scroll
    document.body.style.overflow = 'hidden';
  }

  // Close gallery overlay
  function closeGallery() {
    galleryOverlay.classList.remove('visible');
    document.body.style.overflow = '';
  }

  // Set image src and alt for current index
  function setImageSrc(index) {
    galleryImg.src = imageFiles[index];
    galleryImg.alt = `Wedding image ${index + 1}`;
  }

  // Show next image
  function nextImage() {
    currentIndex = (currentIndex + 1) % imageFiles.length;
    resetTransform();
    fadeImageTo(currentIndex);
  }

  // Show previous image
  function prevImage() {
    currentIndex = (currentIndex - 1 + imageFiles.length) % imageFiles.length;
    resetTransform();
    fadeImageTo(currentIndex);
  }

  // Fade transition for image change
  function fadeImageTo(index) {
    galleryImg.style.opacity = 0;
    setTimeout(() => {
      setImageSrc(index);
      galleryImg.style.opacity = 1;
    }, 250);
  }

  closeBtn.addEventListener('click', closeGallery);

  prevBtn.addEventListener('click', prevImage);
  nextBtn.addEventListener('click', nextImage);

  // Close gallery on overlay click (outside image/content)
  galleryOverlay.addEventListener('click', (e) => {
    if(e.target === galleryOverlay) {
      closeGallery();
    }
  });

  // Keyboard navigation
  document.addEventListener('keydown', (e) => {
    if(!galleryOverlay.classList.contains('visible')) return;

    if(e.key === 'Escape') {
      closeGallery();
    } else if(e.key === 'ArrowRight') {
      nextImage();
    } else if(e.key === 'ArrowLeft') {
      prevImage();
    }
  });

  // Pan and zoom variables
  let scale = 1;
  let originX = 0;
  let originY = 0;
  let startX = 0;
  let startY = 0;
  let isDragging = false;
  let lastX = 0;
  let lastY = 0;

  // Apply transform
  function applyTransform() {
    galleryImg.style.transform = `translate(${originX}px, ${originY}px) scale(${scale})`;
  }

  // Reset transform to defaults
  function resetTransform() {
    scale = 1;
    originX = 0;
    originY = 0;
    applyTransform();
  }

  // Mouse wheel zoom on image wrapper
  imageWrapper.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = galleryImg.getBoundingClientRect();

    // Calculate mouse position relative to image
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Normalize mouse position to scale origin
    const offsetX = (mouseX - originX) / scale;
    const offsetY = (mouseY - originY) / scale;

    // Zoom factor
    const zoomAmount = -e.deltaY * 0.003;
    const newScale = Math.min(Math.max(0.5, scale + zoomAmount), 5);

    // Prevent zooming out beyond 0.5 or in beyond 5
    if(newScale === scale) return;

    // Adjust origin to zoom on mouse position
    originX -= (offsetX * (newScale - scale));
    originY -= (offsetY * (newScale - scale));
    scale = newScale;

    applyTransform();
  }, { passive: false });

  // Touch pinch zoom
  let lastDistance = 0;
  let pinchCenter = null;
  let isPinching = false;

  imageWrapper.addEventListener('touchstart', (e) => {
    if(e.touches.length === 2) {
      isPinching = true;
      lastDistance = getDistance(e.touches[0], e.touches[1]);
      pinchCenter = getMidpoint(e.touches[0], e.touches[1]);
    } else if(e.touches.length === 1) {
      isDragging = true;
      startX = e.touches[0].clientX - originX;
      startY = e.touches[0].clientY - originY;
    }
  }, { passive: false });

  imageWrapper.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if(isPinching && e.touches.length === 2) {
      const distance = getDistance(e.touches[0], e.touches[1]);
      const delta = distance - lastDistance;

      const rect = galleryImg.getBoundingClientRect();
      const mouseX = pinchCenter.x - rect.left;
      const mouseY = pinchCenter.y - rect.top;
      const offsetX = (mouseX - originX) / scale;
      const offsetY = (mouseY - originY) / scale;

      let newScale = scale + delta * 0.01;
      newScale = Math.min(Math.max(0.5, newScale), 5);

      originX -= (offsetX * (newScale - scale));
      originY -= (offsetY * (newScale - scale));
      scale = newScale;

      lastDistance = distance;
      applyTransform();
    } else if(isDragging && e.touches.length === 1) {
      originX = e.touches[0].clientX - startX;
      originY = e.touches[0].clientY - startY;
      applyTransform();
    }
  }, { passive: false });

  imageWrapper.addEventListener('touchend', (e) => {
    if(e.touches.length < 2) isPinching = false;
    if(e.touches.length === 0) isDragging = false;
  });

  // Mouse drag pan
  imageWrapper.addEventListener('mousedown', (e) => {
    e.preventDefault();
    isDragging = true;
    startX = e.clientX - originX;
    startY = e.clientY - originY;
    galleryImg.style.transition = 'none';
  });

  window.addEventListener('mousemove', (e) => {
    if(!isDragging) return;
    originX = e.clientX - startX;
    originY = e.clientY - startY;
    applyTransform();
  });

  window.addEventListener('mouseup', () => {
    if(isDragging) {
      isDragging = false;
      galleryImg.style.transition = 'transform 0.3s ease';
    }
  });

  // Utility: get distance between two touches
  function getDistance(touch1, touch2) {
    const dx = touch2.clientX - touch1.clientX;
    const dy = touch2.clientY - touch1.clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }

  // Utility: get midpoint between two touches
  function getMidpoint(touch1, touch2) {
    return {
      x: (touch1.clientX + touch2.clientX) / 2,
      y: (touch1.clientY + touch2.clientY) / 2
    };
  }
</script>
</body>
</html>